<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="See the docs on ParserDatabase."><title>parser_database - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="parser_database" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0 (5680fa18f 2023-08-23) (built from a source tarball)" data-channel="1.72.0" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../parser_database/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../parser_database/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate parser_database</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">parser_database</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/parser_database/lib.rs.html#1-176">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>See the docs on <a href="./struct.ParserDatabase.html">ParserDatabase</a>.</p>
<h3 id="scope"><a href="#scope">Scope</a></h3>
<p>The ParserDatabase is tasked with gathering information about the schema. It is <em>connector
agnostic</em>: it gathers information and performs generic validations, leaving connector-specific
validations to later phases in datamodel core.</p>
<h3 id="terminology"><a href="#terminology">Terminology</a></h3>
<p>Names:</p>
<ul>
<li><em>name</em>: the item name in the schema for datasources, generators, models, model fields,
composite types, composite type fields, enums and enum variants. The <code>name:</code> argument for
unique constraints, primary keys and relations.</li>
<li><em>mapped name</em>: the name inside an <code>@map()</code> or <code>@@map()</code> attribute of a model, field, enum or
enum value. This is used to determine what the name of the Prisma schema item is in the
database.</li>
<li><em>database name</em>: the name in the database, once both the name of the item and the mapped
name have been taken into account. The logic is always the same: if a mapped name is defined,
then the database name is the mapped name, otherwise it is the name of the item.</li>
<li><em>constraint name</em>: indexes, primary keys and defaults can have a constraint name. It can be
defined with a <code>map:</code> argument or be a default, generated name if the <code>map:</code> argument is not
provided. These usually require a datamodel connector to be defined.</li>
</ul>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="ast/index.html" title="mod parser_database::ast">ast</a></div><div class="desc docblock-short">The AST data structure. It aims to faithfully represent the syntax of a Prisma Schema, with
source span information.</div></li><li><div class="item-name"><a class="mod" href="coerce/index.html" title="mod parser_database::coerce">coerce</a></div><div class="desc docblock-short">Coerce expressions to a specific type, emitting a validation error if the coercion
fails. See the <code>coerce_opt</code> module if you do not want to emit validation errors.</div></li><li><div class="item-name"><a class="mod" href="coerce_opt/index.html" title="mod parser_database::coerce_opt">coerce_opt</a></div><div class="desc docblock-short">Fallible coercions of PSL expressions to more specific types.</div></li><li><div class="item-name"><a class="mod" href="walkers/index.html" title="mod parser_database::walkers">walkers</a></div><div class="desc docblock-short">Convenient access to a datamodel as understood by ParserDatabase.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.IndexFieldPath.html" title="struct parser_database::IndexFieldPath">IndexFieldPath</a></div><div class="desc docblock-short">Defines a path to a field that is not directly in the model.</div></li><li><div class="item-name"><a class="struct" href="struct.ManyToManyRelationId.html" title="struct parser_database::ManyToManyRelationId">ManyToManyRelationId</a></div><div class="desc docblock-short">Identifier for a single implicit many-to-many relation in a Prisma schema.</div></li><li><div class="item-name"><a class="struct" href="struct.ParserDatabase.html" title="struct parser_database::ParserDatabase">ParserDatabase</a></div><div class="desc docblock-short">ParserDatabase is a container for a Schema AST, together with information
gathered during schema validation. Each validation step enriches the
database with information that can be used to work with the schema, without
changing the AST. Instantiating with <code>ParserDatabase::new()</code> will perform a
number of validations and make sure the schema makes sense, but it cannot
fail. In case the schema is invalid, diagnostics will be created and the
resolved information will be incomplete.</div></li><li><div class="item-name"><a class="struct" href="struct.RelationFieldId.html" title="struct parser_database::RelationFieldId">RelationFieldId</a></div><div class="desc docblock-short">An opaque identifier for a model relation field in a schema.</div></li><li><div class="item-name"><a class="struct" href="struct.RelationId.html" title="struct parser_database::RelationId">RelationId</a></div><div class="desc docblock-short">Identifier for a single relation in a Prisma schema.</div></li><li><div class="item-name"><a class="struct" href="struct.ScalarFieldId.html" title="struct parser_database::ScalarFieldId">ScalarFieldId</a></div><div class="desc docblock-short">An opaque identifier for a model scalar field in a schema.</div></li><li><div class="item-name"><a class="struct" href="struct.SourceFile.html" title="struct parser_database::SourceFile">SourceFile</a></div><div class="desc docblock-short">A Prisma schema document.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.IndexAlgorithm.html" title="enum parser_database::IndexAlgorithm">IndexAlgorithm</a></div><div class="desc docblock-short">A type of index as defined by the <code>type: ...</code> argument on an index attribute.</div></li><li><div class="item-name"><a class="enum" href="enum.IndexType.html" title="enum parser_database::IndexType">IndexType</a></div><div class="desc docblock-short">The different types of indexes supported in the Prisma Schema Language.</div></li><li><div class="item-name"><a class="enum" href="enum.OperatorClass.html" title="enum parser_database::OperatorClass">OperatorClass</a></div><div class="desc docblock-short">Defines operators captured by the index. Used with PostgreSQL
GiST/SP-GiST/GIN/BRIN indices.</div></li><li><div class="item-name"><a class="enum" href="enum.ReferentialAction.html" title="enum parser_database::ReferentialAction">ReferentialAction</a></div><div class="desc docblock-short">An action describing the way referential integrity is managed in the system.</div></li><li><div class="item-name"><a class="enum" href="enum.ScalarFieldType.html" title="enum parser_database::ScalarFieldType">ScalarFieldType</a></div><div class="desc docblock-short">The type of a scalar field, parsed and categorized.</div></li><li><div class="item-name"><a class="enum" href="enum.ScalarType.html" title="enum parser_database::ScalarType">ScalarType</a></div><div class="desc docblock-short">Prisma’s builtin scalar types.</div></li><li><div class="item-name"><a class="enum" href="enum.SortOrder.html" title="enum parser_database::SortOrder">SortOrder</a></div><div class="desc docblock-short">The sort order of an index.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.coerce_array.html" title="fn parser_database::coerce_array">coerce_array</a></div><div class="desc docblock-short">Coerce an expression to an array. The coercion function is used to coerce the array elements.</div></li><li><div class="item-name"><a class="fn" href="fn.is_reserved_type_name.html" title="fn parser_database::is_reserved_type_name">is_reserved_type_name</a></div><div class="desc docblock-short">Is this a valid type name for the Prisma Client API?</div></li></ul></section></div></main></body></html>